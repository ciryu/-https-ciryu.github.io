(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{452:function(t,e,n){"use strict";n.r(e);var o=n(28),r=Object(o.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("一个数据库在最基础的层次上需要完成两件事情：当你把数据交给数据库时，它应当把数据存储起来；而后当你向数据库要数据时，它应当把数据返回给你。")]),t._v(" "),n("p",[t._v("在第二章中，我们讨论了数据模型和查询语言，即程序员将数据录入数据库的格式，以及再次要回数据的机制。在本章中我们会从数据库的视角来讨论同样的问题：数据库如何存储我们提供的数据，以及如何在我们需要时重新找到数据。")]),t._v(" "),n("p",[t._v("作为程序员，为什么要关心数据库内部存储与检索的机理？你可能不会去从头开始实现自己的存储引擎，但是你确实需要从许多可用的存储引擎中选择一个合适的。而且为了让存储引擎能在你的工作负载类型上运行良好，你也需要大致了解存储引擎在底层究竟做了什么。")]),t._v(" "),n("p",[t._v("特别需要注意，针对事务性负载优化的和针对分析性负载优化的存储引擎之间存在巨大差异。稍后我们将在 “事务处理还是分析？” 一节中探讨这一区别，并在 “列式存储”中讨论一系列针对分析性负载而优化的存储引擎。")]),t._v(" "),n("p",[t._v("从传统的关系型数据库和很多所谓的“NoSQL”数据库中使用的存储引擎开始。研究两大类存储引擎：日志结构（log-structured） 的存储引擎，以及面向页面（page-oriented） 的存储引擎（例如B树）。")])])}),[],!1,null,null,null);e.default=r.exports}}]);